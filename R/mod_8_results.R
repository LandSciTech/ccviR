#' Test the Results module
#'
#' Includes the report module. Requires the save module for testing.
#'
#' @noRd
#' @examples
#' mod_results_test()
#' mod_results_test(df_loaded = test_df_loaded(),
#'                  NULL, NULL, NULL)

mod_results_test <- function(df_loaded = NULL,
                             species_data = test_species(),
                             spatial = test_spatial(),
                             questions = test_questions()) {

  ui <- ui_setup(mod_results_ui(id = "test"))

  server <- function(input, output, session) {
    shinyOptions("file_dir" = "inst/extdata/")
    volumes <- server_setup()

    saved <- mod_save_server(
      id = "test_save", volumes,
      reactive(species_data),
      spatial = spatial,
      questions = questions,
      index = index)

    index <- mod_results_server(
      id = "test",
      reactive(df_loaded),
      reactive(species_data),
      spatial = spatial,
      questions = questions,
      saved = saved)
  }

  shinyApp(ui, server)
}

mod_results_ui <- function(id) {

  ns <- NS(id)

  tabPanel(
    "Index Results", value = "results",
    fluidRow(
      column(
        12,
        h2("Results"),
        p("This section calculates ", strong("Data completeness"),
          "and the ", strong("Climate Change Vulnerability Index (CCVI)"),
          "using the results of Sections",
          "A, B, C, and D. Once the index has been calculated, a report",
          "summarizing the results of the assessment can be generated by",
          "selecting the 'Generate report' button at the bottom of the page."),

        div(
          id = ns("formData"),

          h3("Data completeness"),
          gt::gt_output(ns("n_factors")),
          strong("Factors completed"), "indicate the number of questions answered out of the total possible. ", br(),
          p(icon("check", style = "color:green"), icon("xmark", style = "color:red"),
            "reflects whether the minimum has been met (B = 3, C = 10 and D = 1).",
            style = "margin-left: 20px"),

          strong("Evidence provided"), "indicates whether all factors completed have also been supplied with a type of evidence.", br(),
          p(icon("check", style = "color:green"), icon("xmark", style = "color:red"),
            "reflects meeting this requirement or not.",
            style = "margin-left:20px"),

          h4("Types of evidence used"),
          plotOutput(ns("plot_evidence"), width = 600, height = 300),
          br(),

          hr(style = "border-top: 2px solid #c8bbbb"),
          h3("CCVI"),
          actionButton(ns("calcIndex"), "Calculate CCVI", class = "btn-primary"),
          p(strong("Note: "), "If changes are made after the index has been",
            "calculated you will need to click 'Calculate' again for them to be applied.")
        ),

        conditionalPanel(
          condition = "output.calcFlag == true",

          uiOutput(NS(id, "all_index_results")),

          h3("Variation in index"),
          p("When multiple values are selected for any of the vulnerability ",
            "factors the average of the values is used to calculate the ",
            "overall index. To test the uncertainty in the result a Monte Carlo ",
            "simulation with 1000 runs is carried out. In each simulation run ",
            "one of the selected values is randomly chosen and the index is ",
            "calculated. The graph below shows the proportion of runs with each",
            " index value for each scenario. "),
          plotOutput(ns("conf_graph"), width = 300, height = 200),
          div(
            id = ns("indplt"),
            #style = 'width:800px;',
            br(),
            h3("Factors contributing to index value"),
            p("The CCVI is calculated by combining the index calculated based on ",
              "exposure, sensitivity and adaptive capacity with the index ",
              "calculated based on documented or modelled responses to climate change. ",
              "The plot below demonstrates which of these had the strongest",
              "influence on the overall calculated index. The lines indicate",
              " the range of scores produced by the Monte Carlo simulations. ",
              "A score of negative one on the vertical ",
              "axis indicates none of the factors in the modelled response to",
              " climate change section were completed"),
            # Might want to add something like this to change width dependent
            # on n facets https://stackoverflow.com/questions/50914398/increase-plot-size-in-shiny-when-using-ggplot-facets

            plotOutput(ns("ind_score_plt"), height = "300px"),
            textOutput(ns("slr")),
            br(), br(),
            p("The score for each vulnerability factor is determined by the ",
              "answers to vulnerability questions (Neutral: 0, Greatly increases: 3)",
              "multiplied by the exposure multiplier for temperature or moisture,",
              "whichever is most relevant to that factor. When multiple values ",
              "are selected for any of the vulnerability ",
              "factors the average of the values is used. These scores are summed ",
              "to determine the index. The plot below demonstrates which factors ",
              "had the highest scores and how exposure impacted the score. ",
              "The lighter coloured bars indicate the maximum possible score ",
              "for that factor. The chart is broken up by section to highlight ",
              "that the B/C and D sections affect the final score differently. ",
              "See the plot above for more details on combining the scores."),
            plotly::plotlyOutput(ns("q_score_plt"), height = "500px")
          ),

          br(), br(),
          mod_report_ui(ns("report")),
          br(),
          div(
            id = "footer",
            style = "float:right",
            actionButton(ns("restart"), "Assess another species",
                         class = "btn-primary")),
          ns = NS(id)
        )
      )
    )
  )
}

mod_results_server <- function(id, df_loaded, species_data, spatial,
                               questions, saved) {

  stopifnot(is.reactive(df_loaded))
  stopifnot(is.reactive(species_data))
  purrr::map(spatial, ~stopifnot(is.reactive(.x)))
  purrr::map(questions, ~stopifnot(is.reactive(.x)))

  # Split up reactives
  spat_res <- spatial$spat_res
  hs_rast <- spatial$hs_rast
  clim_readme <- spatial$clim_readme
  range_poly <- spatial$range_poly
  hs_rcl_mat <- spatial$hs_rcl_mat

  moduleServer(id, function(input, output, session) {

    ns <- session$ns

    # Setup --------------------
    index_res <- reactiveVal()

    # Restore data ----------------
    observeEvent(df_loaded(), {
      index_res(recreate_index_res(df_loaded()))
    })

    # Calculate Index value #================================

    # Gather all the form inputs
    vuln_df <- reactive({
      bind_elements(questions, "questions") %>%
        rows_append(data.frame(Code = "Z2", Value1 = species_data()$cave)) %>%
        rows_append(data.frame(Code = "Z3", Value1 = species_data()$mig)) %>%
        mutate(Species = species_data()$species_name)
    })

    coms_df <- reactive(bind_elements(questions, "comments"))

    observeEvent(input$calcIndex,{
      if(!isTruthy(spat_res())){
        showNotification(
          p(strong("Error: "),
            "Please run the spatial data analysis before trying to calculate the index."),
          type = "error",
          duration = 10)
        req(FALSE)
      }

      calc_vulnerability(spat_res(), vuln_df(), species_data()$tax_grp) %>%
        index_res()
    })

    output$species_name <- renderText(species_data()$species_name)


    # Scenario Dials -------------------
    # insert index dials for each scenario
    scenarios <- reactive({
      req(index_res())
      ind_ls <- index_res() %>%
        arrange(desc(.data$scenario_name)) %>%
        split(index_res()$scenario_name)
    })

    # Create UIs and Outputs - Looping over nested modules
    # NOTE: Require ns() in UI (I think) because UIs inside another UI.
    output$all_index_results <- renderUI({
      purrr::map(seq_along(scenarios()), ~indexOutUI2(ns(.x)))
    })
    observeEvent(scenarios(), {
      purrr::map(seq_along(scenarios()), ~indexOutServer2(.x, scenarios()[[.x]]))
    })

    # a flag to hide results until calculated
    output$calcFlag <- reactive(isTruthy(index_res()))
    outputOptions(output, "calcFlag", suspendWhenHidden = FALSE)


    # Plots and Tables ----------------------------------

    # Get a list of answers and evidence
    answers <- reactive({
      purrr::map(
        questions,
        ~answered_n(.x(), tax_grp = species_data()$tax_grp, spatial$spat_res()))
    })


    ## Table - Data completeness ------------------
    output$n_factors <- gt::render_gt({
      req(answers())

      purrr::map(answers(), count_n) %>%
        purrr::list_rbind() %>%
        dplyr::left_join(
          tibble(
            sec = c("B", "C", "D"),
            Section = c("Section B: Indirect Exposure to Climate Change",
                        "Section C: Sensitivity and Adaptive Capacity",
                        "Section D: Documented or Modeled Response to Climate Change")),
          by = "sec") %>%
        dplyr::relocate("Section") %>%
        gt::gt() %>%
        gt::cols_hide(c("sec", "q_total", "q_ans", "e_total", "e_ans", "req")) %>%
        gt::cols_add(
          status1 = dplyr::if_else(.data$q_ans >= .data$req, "check", "xmark"),
          .after = c("q_txt")) %>%
        gt::cols_add(
          status2 = dplyr::if_else(.data$e_ans == .data$e_total, "check", "xmark"),
          .after = c("e_txt")) %>%
        gt::cols_label("status1" = "", "status2" = "",
                       "q_txt" = "Factors completed",
                       "e_txt" = "Evidence provided") %>%
        gt::fmt_icon(
          columns = c("status1", "status2"),
          fill_color = c("check" = "green", "xmark" = "red")
        ) %>%
        gt::cols_merge(c("q_txt", "status1"),
                       pattern = "{1}&nbsp;&nbsp;&nbsp;{2}") %>%
        gt::cols_merge(c("e_txt", "status2"),
                       pattern = "{1}&nbsp;&nbsp;&nbsp;{2}") %>%
        gt::tab_options(table.font.size = 14,
                        column_labels.padding.horizontal = 10,
                        column_labels.padding = 2,
                        data_row.padding = 2) %>%
        gt::cols_align(align = "center", columns = "Section") %>%
        gt::tab_style(
          style = gt::cell_text(weight = "bold", align = "center", v_align = "middle"),
          location = gt::cells_column_labels()) %>%
        gt::tab_options(table.border.bottom.style = "none")

    })

    output$slr <- renderText({
      if(is.null(index_res()[["slr_vuln"]])){
        return(NULL)
      }
      if(!any(index_res()$slr_vuln)){
        return(NULL)
      }
      scn_slr <- filter(index_res(), .data$slr_vuln) %>% pull(.data$scenario_name)
      paste0("The index value for this species in scenario ",
             paste0(scn_slr, collapse = ", "), " was increased to ",
             "'Extremely Vulnerable' because it is vulnerable to rising ",
             "sea levels and has significant dispersal barriers")
    })


    ## Plot Variation in Index ------------------------

    #output$conf_index <- renderText(index_res()$conf_index)
    output$conf_graph <- renderPlot({
      req(index_res())
      plot_conf_score(index_res())
    })

    ## Plot - Comparison of thresholds and results ----------------
    output$ind_score_plt <- renderPlot({
      validate(need(any(index_res()$index != "IE"),
                    "Insufficient Evidence: No Index Value"))
      plot_score_index(index_res())
    })

    ## Plot - Individual questions ------------------
    output$q_score_plt <- plotly::renderPlotly({
      req(index_res())
      index_res() %>%
        select("scenario_name", "vuln_df") %>%
        tidyr::unnest(.data$vuln_df) %>%
        plot_q_score()
    })

    ## Plot - Summary of data evidence ------
    output$plot_evidence <- renderPlot({
      plot_evidence(purrr::list_rbind(answers()))
    })



    # # helpful for testing
    #  shinyjs::runcodeServer()

    observeEvent(input$restart,{
      restoreURL <- paste0(session$clientData$url_protocol, "//",
                           session$clientData$url_hostname, ":",
                           session$clientData$url_port)

      # redirect user to restoreURL
      shinyjs::runjs(sprintf("window.location = '%s';", restoreURL))
    })



    index <- eventReactive(index_res(), {
       req(index_res())
       #message("index out_data")
       vuln_df <- purrr::map_dfr(index_res()$vuln_df, widen_vuln_coms,
                                 coms_df = coms_df())

       conf_df <- index_res() %>%
         select("scenario_name", "mc_results") %>%
         mutate(mc_results = purrr::map(
           .data$mc_results, ~.x$index %>%
             factor(levels = c( "EV", "HV", "MV", "LV", "IE")) %>%
             table() %>%
             prop.table() %>%
             as.data.frame(stringsAsFactors = FALSE) %>%
             `names<-`(c("index", "frequency")))) %>%
         pull(.data$mc_results) %>%
         purrr::map_dfr(
           ~ mutate(.x, index = paste0("MC_freq_", .data$index)) %>%
             tidyr::pivot_wider(names_from = "index",
                                values_from = "frequency"))

       ind_df <- data.frame(CCVI_index = index_res()$index,
                            CCVI_conf_index = index_res()$conf_index,
                            mig_exposure = index_res()$mig_exp,
                            b_c_score = index_res()$b_c_score,
                            d_score = index_res()$d_score)

       bind_cols(ind_df, conf_df, vuln_df)
     })

    # Reports -----------------------------------

    # Report module
    mod_report_server(
      id = "report",
      saved = saved)


    # Return ------------------------------------
    reactive(if(is_ready(index())) index() else NULL)
  })

}
